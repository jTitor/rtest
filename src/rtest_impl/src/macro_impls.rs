/*!
 * Defines the functions that perform the implementations
 * of the macros defined in the rtest_user_macros crate.
 */
use proc_macro::TokenStream;

/**
 * Marks a function as a test function.
 * Can be used as #[test(main)], in which case
 * the function's test will run on the main thread.
 */
pub fn expose_test(attrib: TokenStream, item: TokenStream) -> TokenStream {
	//TODO
	//Does attrib.tolower() contain "main"?
	//	If so, tokenstream should create a main test that
	//	calls the function.
	//	Else, tokenstream should create a standard test
	//	that calls the function.
	unimplemented!();
	//Create token stream to augment input with.
	let expanded = unimplemented!();

	//Append to input tokenstream.
	unimplemented!();

	expanded
}

/**
 * Marks a function to be ignored by the test system.
 * When testing is run, the function will be acknowledged,
 * but will not be executed by the test system.
 */
pub fn expose_ignore(item: TokenStream) -> TokenStream {
	unimplemented!();
	//Codegen here...
	let expanded = macro_impls::expose_ignore(item);

	//TODO: this goes in rtest_impl, NOT here.
	//Create token stream to augment input with.
	//Create an ignore with the function's name.
	//Append to input tokenstream.

	expanded
}

/**
 * Exposes a module as a test module, reexporting
 * it as a public module if it wasn't already public.
 */
pub fn expose_test_mod(item: TokenStream) -> TokenStream {
	//Get the input item as a ItemMod.
	unimplemented!();
	//If conversion fails, return as is.
	unimplemented!();
	//Otherwise, mark mod as pub.
	unimplemented!();
	//Convert back to TokenStream and return that.
	unimplemented!();
}

/**
 * Initializes rtest for the crate this macro is used in,
 * generating the unit tests and harness entry point.
 * 
 * Apply this macro via init_rtest!() in the
 * root module of your unit test crate.
 * Only apply this macro once.
 */
pub fn generate_harness_entry(file_path: &str) -> TokenStream {
	//TODO
	//Send a syn traverse to the given file.
	//Use the output to define our list of test fn calls.
	unimplemented!();

	//Apply the codegen...
	let expanded = unimplemented!();

	//And return the augmented code	
	expanded
}

/**
 * Runs the harness entry point generated by init_rtest!().
 * 
 * Call this in your unit test crate's main() function with
 * run_rtest!().
 * This will call std::process::exit(), so there's no point
 * trying to call this more than once.
 */
pub fn generate_harness_invocation() -> TokenStream {
	//Straightforward quote!{} of a function invocation
	let result = unimplemented!();

	result
}